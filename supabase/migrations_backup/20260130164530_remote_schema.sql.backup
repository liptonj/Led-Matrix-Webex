create extension if not exists "pg_cron" with schema "pg_catalog";

create sequence "display"."pairing_heartbeats_id_seq";

-- These drops are conditional - tables may not exist if migrations haven't been applied yet
drop trigger if exists "connection_heartbeats_updated_at" on "display"."connection_heartbeats";

drop trigger if exists "display_pages_updated_at" on "display"."display_pages";

drop trigger if exists "feeds_updated_at" on "display"."feeds";

drop trigger if exists "pairings_status_change" on "display"."pairings";

drop policy if exists "Devices can read own heartbeat" on "display"."connection_heartbeats";

drop policy if exists "Service role full access to heartbeats" on "display"."connection_heartbeats";

drop policy "display_pages_admin_all" on "display"."display_pages";

drop policy "display_pages_device_read" on "display"."display_pages";

drop policy "display_pages_service_full" on "display"."display_pages";

drop policy "feed_data_admin_all" on "display"."feed_data";

drop policy "feed_data_device_read" on "display"."feed_data";

drop policy "feed_data_service_full" on "display"."feed_data";

drop policy "feeds_admin_all" on "display"."feeds";

drop policy "feeds_device_read" on "display"."feeds";

drop policy "feeds_service_full" on "display"."feeds";

revoke select on table "display"."connection_heartbeats" from "anon";

revoke delete on table "display"."connection_heartbeats" from "authenticated";

revoke insert on table "display"."connection_heartbeats" from "authenticated";

revoke select on table "display"."connection_heartbeats" from "authenticated";

revoke update on table "display"."connection_heartbeats" from "authenticated";

revoke delete on table "display"."connection_heartbeats" from "service_role";

revoke insert on table "display"."connection_heartbeats" from "service_role";

revoke references on table "display"."connection_heartbeats" from "service_role";

revoke select on table "display"."connection_heartbeats" from "service_role";

revoke trigger on table "display"."connection_heartbeats" from "service_role";

revoke truncate on table "display"."connection_heartbeats" from "service_role";

revoke update on table "display"."connection_heartbeats" from "service_role";

revoke select on table "display"."display_pages" from "anon";

revoke delete on table "display"."display_pages" from "authenticated";

revoke insert on table "display"."display_pages" from "authenticated";

revoke select on table "display"."display_pages" from "authenticated";

revoke update on table "display"."display_pages" from "authenticated";

revoke delete on table "display"."display_pages" from "service_role";

revoke insert on table "display"."display_pages" from "service_role";

revoke references on table "display"."display_pages" from "service_role";

revoke select on table "display"."display_pages" from "service_role";

revoke trigger on table "display"."display_pages" from "service_role";

revoke truncate on table "display"."display_pages" from "service_role";

revoke update on table "display"."display_pages" from "service_role";

revoke select on table "display"."feed_data" from "anon";

revoke delete on table "display"."feed_data" from "authenticated";

revoke insert on table "display"."feed_data" from "authenticated";

revoke select on table "display"."feed_data" from "authenticated";

revoke update on table "display"."feed_data" from "authenticated";

revoke delete on table "display"."feed_data" from "service_role";

revoke insert on table "display"."feed_data" from "service_role";

revoke references on table "display"."feed_data" from "service_role";

revoke select on table "display"."feed_data" from "service_role";

revoke trigger on table "display"."feed_data" from "service_role";

revoke truncate on table "display"."feed_data" from "service_role";

revoke update on table "display"."feed_data" from "service_role";

revoke select on table "display"."feeds" from "anon";

revoke delete on table "display"."feeds" from "authenticated";

revoke insert on table "display"."feeds" from "authenticated";

revoke select on table "display"."feeds" from "authenticated";

revoke update on table "display"."feeds" from "authenticated";

revoke delete on table "display"."feeds" from "service_role";

revoke insert on table "display"."feeds" from "service_role";

revoke references on table "display"."feeds" from "service_role";

revoke select on table "display"."feeds" from "service_role";

revoke trigger on table "display"."feeds" from "service_role";

revoke truncate on table "display"."feeds" from "service_role";

revoke update on table "display"."feeds" from "service_role";

-- Conditional constraint drop (table may not exist)
do $$ begin
  if exists (select 1 from information_schema.tables where table_schema = 'display' and table_name = 'connection_heartbeats') then
    alter table "display"."connection_heartbeats" drop constraint if exists "connection_heartbeats_pairing_code_fkey";
  end if;
end $$;

alter table "display"."display_pages" drop constraint "display_pages_feed_id_fkey";

alter table "display"."display_pages" drop constraint "display_pages_page_type_check";

alter table "display"."display_pages" drop constraint "display_pages_pairing_code_fkey";

alter table "display"."feed_data" drop constraint "feed_data_feed_id_fkey";

alter table "display"."feeds" drop constraint "feeds_feed_type_check";

alter table "display"."feeds" drop constraint "feeds_pairing_code_fkey";

drop function if exists "display"."expire_feed_data"();

drop function if exists "display"."get_active_feed_content"(p_pairing_code text);

drop function if exists "display"."get_active_pages"(p_pairing_code text);

drop function if exists "display"."get_latest_feed_data"(p_feed_id uuid);

drop function if exists "display"."status_values_changed"(p_pairing_code text, p_webex_status text, p_camera_on boolean, p_mic_muted boolean, p_in_call boolean, p_display_name text, p_app_connected boolean);

drop function if exists "display"."update_status_timestamp"();

-- Conditional constraint drop (table may not exist)
do $$ begin
  if exists (select 1 from information_schema.tables where table_schema = 'display' and table_name = 'connection_heartbeats') then
    alter table "display"."connection_heartbeats" drop constraint if exists "connection_heartbeats_pkey";
  end if;
end $$;

alter table "display"."display_pages" drop constraint "display_pages_pkey";

alter table "display"."feed_data" drop constraint "feed_data_pkey";

alter table "display"."feeds" drop constraint "feeds_pkey";

drop index if exists "display"."connection_heartbeats_pkey";

drop index if exists "display"."display_pages_pkey";

drop index if exists "display"."feed_data_pkey";

drop index if exists "display"."feeds_pkey";

drop index if exists "display"."idx_display_pages_feed";

drop index if exists "display"."idx_display_pages_pairing";

drop index if exists "display"."idx_display_pages_pairing_enabled";

drop index if exists "display"."idx_display_pages_unique";

drop index if exists "display"."idx_feed_data_expires";

drop index if exists "display"."idx_feed_data_feed";

drop index if exists "display"."idx_feed_data_valid";

drop index if exists "display"."idx_feeds_fetch";

drop index if exists "display"."idx_feeds_pairing";

drop index if exists "display"."idx_feeds_pairing_enabled";

drop index if exists "display"."idx_feeds_type";

drop index if exists "display"."idx_heartbeats_pairing";

drop index if exists "display"."idx_pairings_status_updated";

-- Conditional table drop (may not exist if migrations haven't been applied)
drop table if exists "display"."connection_heartbeats";

drop table "display"."display_pages";

drop table "display"."feed_data";

drop table "display"."feeds";


  create table "display"."pairing_heartbeats" (
    "id" bigint not null default nextval('display.pairing_heartbeats_id_seq'::regclass),
    "pairing_code" text not null,
    "sent_at" timestamp with time zone not null default now()
      );


-- Conditional column drop (may not exist if migration 20260130210000 hasn't been applied)
do $$ begin
  if exists (
    select 1 from information_schema.columns 
    where table_schema = 'display' 
    and table_name = 'pairings' 
    and column_name = 'status_updated_at'
  ) then
    alter table "display"."pairings" drop column "status_updated_at";
  end if;
end $$;

alter sequence "display"."pairing_heartbeats_id_seq" owned by "display"."pairing_heartbeats"."id";

CREATE INDEX idx_commands_pairing_code ON display.commands USING btree (pairing_code);

CREATE INDEX idx_pairings_pairing_code ON display.pairings USING btree (pairing_code);

CREATE INDEX idx_user_devices_user_serial ON display.user_devices USING btree (user_id, serial_number);

CREATE UNIQUE INDEX oauth_clients_provider_client_id_key ON display.oauth_clients USING btree (provider, client_id);

CREATE INDEX oauth_tokens_pairing_idx ON display.oauth_tokens USING btree (pairing_code);

CREATE UNIQUE INDEX oauth_tokens_provider_device_id_key ON display.oauth_tokens USING btree (provider, device_id);

CREATE INDEX oauth_tokens_serial_idx ON display.oauth_tokens USING btree (serial_number);

CREATE UNIQUE INDEX pairing_heartbeats_pkey ON display.pairing_heartbeats USING btree (id);

alter table "display"."pairing_heartbeats" add constraint "pairing_heartbeats_pkey" PRIMARY KEY using index "pairing_heartbeats_pkey";

alter table "display"."oauth_clients" add constraint "oauth_clients_provider_client_id_key" UNIQUE using index "oauth_clients_provider_client_id_key";

alter table "display"."oauth_tokens" add constraint "oauth_tokens_provider_device_id_key" UNIQUE using index "oauth_tokens_provider_device_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION display.broadcast_commands_changes()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  topic text;
begin
  topic := 'pairing:' || coalesce(new.pairing_code, old.pairing_code) || ':events';
  perform realtime.broadcast_changes(
    topic,
    'command_changed',
    tg_op,
    tg_table_name,
    tg_table_schema,
    new,
    old,
    'ROW'
  );
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.display_commands_broadcast_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  code text;
BEGIN
  code := COALESCE(NEW.pairing_code, OLD.pairing_code);
  IF code IS NULL THEN
    RETURN COALESCE(NEW, OLD);
  END IF;

  PERFORM realtime.broadcast_changes(
    'pairing:' || code || ':events',
    TG_OP,
    TG_OP,
    TG_TABLE_NAME,
    TG_TABLE_SCHEMA,
    NEW,
    OLD
  );

  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.display_firmware_updates_broadcast_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  code text;
BEGIN
  code := COALESCE(NEW.pairing_code, OLD.pairing_code);
  IF code IS NULL THEN
    RETURN COALESCE(NEW, OLD);
  END IF;

  PERFORM realtime.broadcast_changes(
    'pairing:' || code || ':events',
    TG_OP,
    TG_OP,
    TG_TABLE_NAME,
    TG_TABLE_SCHEMA,
    NEW,
    OLD
  );

  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.display_heartbeats_broadcast_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM realtime.broadcast_changes(
    'pairing:' || NEW.pairing_code || ':events',
    TG_OP,
    'heartbeat',
    TG_TABLE_NAME,
    TG_TABLE_SCHEMA,
    NEW,
    NULL
  );
  RETURN NEW;
END;
$function$
;

grant select on table "display"."pairing_heartbeats" to "anon";

grant delete on table "display"."pairing_heartbeats" to "authenticated";

grant insert on table "display"."pairing_heartbeats" to "authenticated";

grant select on table "display"."pairing_heartbeats" to "authenticated";

grant update on table "display"."pairing_heartbeats" to "authenticated";

grant delete on table "display"."pairing_heartbeats" to "service_role";

grant insert on table "display"."pairing_heartbeats" to "service_role";

grant references on table "display"."pairing_heartbeats" to "service_role";

grant select on table "display"."pairing_heartbeats" to "service_role";

grant trigger on table "display"."pairing_heartbeats" to "service_role";

grant truncate on table "display"."pairing_heartbeats" to "service_role";

grant update on table "display"."pairing_heartbeats" to "service_role";


  create policy "admin select oauth clients"
  on "display"."oauth_clients"
  as permissive
  for select
  to public
using (display.is_admin());



  create policy "admin select oauth tokens"
  on "display"."oauth_tokens"
  as permissive
  for select
  to public
using (display.is_admin());


CREATE TRIGGER display_commands_broadcast AFTER INSERT OR DELETE OR UPDATE ON display.commands FOR EACH ROW EXECUTE FUNCTION display.broadcast_commands_changes();

CREATE TRIGGER tr_display_commands_broadcast AFTER INSERT OR DELETE OR UPDATE ON display.commands FOR EACH ROW EXECUTE FUNCTION public.display_commands_broadcast_trigger();

CREATE TRIGGER tr_display_heartbeats_broadcast AFTER INSERT ON display.pairing_heartbeats FOR EACH ROW EXECUTE FUNCTION public.display_heartbeats_broadcast_trigger();


  create policy "pairing_can_read"
  on "realtime"."messages"
  as permissive
  for select
  to authenticated
using (((topic ~~ 'pairing:%'::text) AND (split_part(topic, ':'::text, 2) = (auth.jwt() ->> 'pairing_code'::text))));



  create policy "pairing_can_write"
  on "realtime"."messages"
  as permissive
  for insert
  to authenticated
with check (((private = true) AND (split_part(topic, ':'::text, 1) = 'pairing'::text) AND ((auth.jwt() ->> 'pairing_code'::text) = split_part(topic, ':'::text, 2))));



