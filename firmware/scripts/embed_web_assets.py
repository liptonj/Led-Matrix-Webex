# mypy: ignore-errors
"""
Embed Web Assets Build Script for PlatformIO.

This script runs as a pre-build step to:
1. Read web files from the data/ directory
2. Gzip compress each file
3. Generate a C header with the compressed data as byte arrays

The generated header allows serving web assets directly from firmware
flash memory, eliminating the need for LittleFS for static files.
"""
import gzip
import os
from pathlib import Path

Import("env")

# File extensions to embed and their content types
CONTENT_TYPES = {
    ".html": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
    ".json": "application/json",
    ".svg": "image/svg+xml",
    ".png": "image/png",
    ".ico": "image/x-icon",
}

# Files/patterns to skip
SKIP_FILES = {".bootstrap_ui", ".gitkeep", ".DS_Store"}

# File extensions to skip (documentation, configs, etc.)
SKIP_EXTENSIONS = {".md", ".txt", ".pdf", ".doc", ".docx"}

# Directories to skip (development/test/build artifacts)
SKIP_DIRS = {"node_modules", "__tests__", "coverage", ".git", ".pio"}


def get_content_type(filename: str) -> str:
    """Get the content type for a file based on extension."""
    ext = Path(filename).suffix.lower()
    return CONTENT_TYPES.get(ext, "application/octet-stream")


def to_c_array_name(filepath: str, data_dir: str) -> str:
    """Convert a file path to a valid C variable name."""
    # Get relative path from data directory
    rel_path = os.path.relpath(filepath, data_dir)
    # Replace path separators and dots with underscores
    name = rel_path.replace("/", "_").replace("\\", "_").replace(".", "_").replace("-", "_")
    return name


def to_url_path(filepath: str, data_dir: str) -> str:
    """Convert a file path to a URL path."""
    rel_path = os.path.relpath(filepath, data_dir)
    # Use forward slashes for URL
    url_path = "/" + rel_path.replace("\\", "/")
    return url_path


def generate_c_array(data: bytes, name: str) -> str:
    """Generate a C array from binary data."""
    lines = []
    lines.append(f"const uint8_t {name}[] PROGMEM = {{")
    
    # Format bytes in rows of 16
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_values = ", ".join(f"0x{b:02x}" for b in chunk)
        lines.append(f"    {hex_values},")
    
    lines.append("};")
    lines.append(f"const size_t {name}_len = {len(data)};")
    return "\n".join(lines)


def find_web_files(data_dir: str) -> list:
    """Find all web files to embed."""
    files = []
    
    if not os.path.exists(data_dir):
        return files
    
    for root, dirs, filenames in os.walk(data_dir):
        # Skip development/test directories
        dirs[:] = [d for d in dirs if d not in SKIP_DIRS and not d.startswith(".")]
        
        for filename in filenames:
            # Skip hidden and special files
            if filename in SKIP_FILES or filename.startswith("."):
                continue
            
            filepath = os.path.join(root, filename)
            ext = Path(filename).suffix.lower()
            
            # Skip documentation and config files
            if ext in SKIP_EXTENSIONS:
                continue
            
            # Only embed files with known content types
            if ext in CONTENT_TYPES:
                files.append(filepath)
    
    return sorted(files)


def generate_embedded_assets_header(data_dir: str, output_path: str) -> None:
    """Generate the embedded_assets.h header file."""
    files = find_web_files(data_dir)
    
    if not files:
        print(f"[EMBED] No web files found in {data_dir}")
        return
    
    print(f"[EMBED] Processing {len(files)} web files from {data_dir}")
    
    lines = []
    lines.append("/**")
    lines.append(" * @file embedded_assets.h")
    lines.append(" * @brief Auto-generated embedded web assets")
    lines.append(" * ")
    lines.append(" * DO NOT EDIT - Generated by embed_web_assets.py")
    lines.append(" */")
    lines.append("")
    lines.append("#ifndef EMBEDDED_ASSETS_H")
    lines.append("#define EMBEDDED_ASSETS_H")
    lines.append("")
    lines.append("#include <Arduino.h>")
    lines.append("#include <pgmspace.h>")
    lines.append("")
    
    # Track asset metadata for the asset table
    assets = []
    
    # Process each file
    for filepath in files:
        filename = os.path.basename(filepath)
        array_name = to_c_array_name(filepath, data_dir) + "_gz"
        url_path = to_url_path(filepath, data_dir)
        content_type = get_content_type(filename)
        
        # Read and compress the file
        with open(filepath, "rb") as f:
            original_data = f.read()
        
        compressed_data = gzip.compress(original_data, compresslevel=9)
        
        original_size = len(original_data)
        compressed_size = len(compressed_data)
        ratio = (1 - compressed_size / original_size) * 100 if original_size > 0 else 0
        
        print(f"[EMBED] {url_path}: {original_size} -> {compressed_size} bytes ({ratio:.1f}% reduction)")
        
        # Generate C array
        lines.append(f"// {url_path} ({original_size} bytes -> {compressed_size} bytes gzipped)")
        lines.append(generate_c_array(compressed_data, array_name))
        lines.append("")
        
        assets.append({
            "url_path": url_path,
            "array_name": array_name,
            "content_type": content_type,
            "original_size": original_size,
            "compressed_size": compressed_size,
        })
    
    # Generate asset metadata structure
    lines.append("// Asset metadata for route registration")
    lines.append("struct EmbeddedAsset {")
    lines.append("    const char* url_path;")
    lines.append("    const uint8_t* data;")
    lines.append("    size_t size;")
    lines.append("    const char* content_type;")
    lines.append("    size_t original_size;")
    lines.append("};")
    lines.append("")
    
    # Generate asset table
    lines.append(f"const EmbeddedAsset EMBEDDED_ASSETS[] = {{")
    for asset in assets:
        lines.append(f'    {{"{asset["url_path"]}", {asset["array_name"]}, {asset["compressed_size"]}, "{asset["content_type"]}", {asset["original_size"]}}},')
    lines.append("};")
    lines.append(f"const size_t EMBEDDED_ASSETS_COUNT = {len(assets)};")
    lines.append("")
    lines.append("#endif // EMBEDDED_ASSETS_H")
    
    # Write the header file
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    
    total_original = sum(a["original_size"] for a in assets)
    total_compressed = sum(a["compressed_size"] for a in assets)
    total_ratio = (1 - total_compressed / total_original) * 100 if total_original > 0 else 0
    
    print(f"[EMBED] Generated {output_path}")
    print(f"[EMBED] Total: {total_original} -> {total_compressed} bytes ({total_ratio:.1f}% reduction)")


def run_embed_assets(env):
    """Run asset embedding immediately when script loads."""
    project_dir = env.subst("$PROJECT_DIR")
    data_dir = os.path.join(project_dir, "data")
    
    # Determine output path based on project structure
    if "bootstrap" in project_dir.lower():
        output_path = os.path.join(project_dir, "src", "embedded_assets.h")
    else:
        output_path = os.path.join(project_dir, "src", "web", "embedded_assets.h")
    
    generate_embedded_assets_header(data_dir, output_path)


# Run immediately when script loads (during PlatformIO's pre-build phase)
# This ensures the header is generated before compilation starts
run_embed_assets(env)
