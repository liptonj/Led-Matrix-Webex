# GitHub Actions - Azure Bridge Deployment
# Automatically builds and deploys the bridge server to Azure Container Instances

name: Deploy Bridge to Azure

on:
  push:
    branches:
      - main
    paths:
      - 'bridge/**'
      - '.github/workflows/deploy-bridge-azure.yml'
  release:
    types: [published]
  workflow_dispatch:  # Allow manual deployment

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/webex-bridge
  AZURE_RESOURCE_GROUP: webex-bridge-rg
  AZURE_CONTAINER_NAME: webex-bridge
  AZURE_LOCATION: eastus

jobs:
  # ============================================================================
  # Build and Push Docker Image to GitHub Container Registry
  # ============================================================================
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-version: ${{ steps.meta.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./bridge
          file: ./bridge/Dockerfile.azure
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64  # Azure Container Instances supports amd64

      - name: Image summary
        run: |
          echo "### Docker Image Built ðŸ³" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** ${{ env.REGISTRY }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Size:** $(docker images --format '{{.Repository}}:{{.Tag}} {{.Size}}' | grep webex-bridge | head -1 || echo 'N/A')" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Deploy to Azure Container Instances
  # ============================================================================
  deploy-to-azure:
    name: Deploy to Azure
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.event_name == 'release'
    permissions:
      contents: read
      id-token: write  # For Azure OIDC authentication

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set subscription
        run: |
          az account set --subscription "71beea79-9d64-4c0f-96a6-d490613ddfdb"
          az account show --query "{Name:name, ID:id}" -o table

      - name: Check if resource group exists
        id: check-rg
        run: |
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ“ Resource group exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âš  Resource group does not exist"
          fi

      - name: Create resource group
        if: steps.check-rg.outputs.exists == 'false'
        run: |
          echo "Creating resource group: ${{ env.AZURE_RESOURCE_GROUP }}"
          az group create \
            --name ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }}

      - name: Check if storage account exists
        id: check-storage
        run: |
          STORAGE_ACCOUNT="webexbridgedata"
          if az storage account show \
            --name $STORAGE_ACCOUNT \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "account=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
            echo "âœ“ Storage account exists: $STORAGE_ACCOUNT"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âš  Storage account does not exist"
          fi

      - name: Create storage account and file share
        if: steps.check-storage.outputs.exists == 'false'
        id: create-storage
        run: |
          # Generate unique storage account name
          STORAGE_ACCOUNT="webexbridgedata$(date +%s | tail -c 5)"
          echo "Creating storage account: $STORAGE_ACCOUNT"

          az storage account create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name $STORAGE_ACCOUNT \
            --location ${{ env.AZURE_LOCATION }} \
            --sku Standard_LRS \
            --output table

          STORAGE_KEY=$(az storage account keys list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --account-name $STORAGE_ACCOUNT \
            --query "[0].value" -o tsv)

          echo "Creating file share..."
          az storage share create \
            --name bridgedata \
            --account-name $STORAGE_ACCOUNT \
            --account-key $STORAGE_KEY \
            --output table

          echo "account=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "key=$STORAGE_KEY" >> $GITHUB_OUTPUT

      - name: Get storage credentials
        id: storage
        run: |
          if [ "${{ steps.check-storage.outputs.exists }}" == "true" ]; then
            STORAGE_ACCOUNT="${{ steps.check-storage.outputs.account }}"
          else
            STORAGE_ACCOUNT="${{ steps.create-storage.outputs.account }}"
          fi

          STORAGE_KEY=$(az storage account keys list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --account-name $STORAGE_ACCOUNT \
            --query "[0].value" -o tsv)

          echo "account=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "::add-mask::$STORAGE_KEY"
          echo "key=$STORAGE_KEY" >> $GITHUB_OUTPUT

      - name: Delete existing container (if exists)
        run: |
          if az container show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_NAME }} &> /dev/null; then
            echo "Deleting existing container..."
            az container delete \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.AZURE_CONTAINER_NAME }} \
              --yes
            echo "Waiting for deletion to complete..."
            sleep 10
          else
            echo "No existing container to delete"
          fi

      - name: Deploy to Azure Container Instances
        run: |
          # Extract image name (use latest tag for main branch)
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"

          echo "Deploying container with image: $IMAGE_TAG"

          az container create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_NAME }} \
            --image $IMAGE_TAG \
            --cpu 0.5 \
            --memory 0.5 \
            --ports 8080 \
            --protocol TCP \
            --restart-policy Always \
            --environment-variables \
              WS_PORT=8080 \
              LOG_LEVEL=info \
              DATA_DIR=/data \
            --azure-file-volume-account-name ${{ steps.storage.outputs.account }} \
            --azure-file-volume-account-key ${{ steps.storage.outputs.key }} \
            --azure-file-volume-share-name bridgedata \
            --azure-file-volume-mount-path /data \
            --output table

          echo "Waiting for container to be ready..."
          sleep 5

      - name: Get deployment info
        id: deploy-info
        run: |
          CONTAINER_IP=$(az container show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_NAME }} \
            --query ipAddress.ip -o tsv)

          CONTAINER_STATE=$(az container show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_NAME }} \
            --query instanceView.state -o tsv)

          echo "ip=$CONTAINER_IP" >> $GITHUB_OUTPUT
          echo "state=$CONTAINER_STATE" >> $GITHUB_OUTPUT

      - name: Show container logs
        if: always()
        run: |
          echo "Container logs (last 50 lines):"
          az container logs \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_NAME }} || echo "No logs available yet"

      - name: Deployment summary
        run: |
          echo "### Azure Deployment Complete â˜ï¸" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Resource Group:** ${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_STEP_SUMMARY
          echo "**Container Name:** ${{ env.AZURE_CONTAINER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Location:** ${{ env.AZURE_LOCATION }}" >> $GITHUB_STEP_SUMMARY
          echo "**IP Address:** ${{ steps.deploy-info.outputs.ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**State:** ${{ steps.deploy-info.outputs.state }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Update Cloudflare DNS: bridge.5ls.us â†’ ${{ steps.deploy-info.outputs.ip }}" >> $GITHUB_STEP_SUMMARY
          echo "2. Enable Cloudflare proxy (orange cloud)" >> $GITHUB_STEP_SUMMARY
          echo "3. Update bridge-config.json with: wss://bridge.5ls.us" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**View Logs:**" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "az container logs --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_CONTAINER_NAME }} --follow" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Health Check (verify deployment)
  # ============================================================================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy-to-azure
    if: github.ref == 'refs/heads/main' || github.event_name == 'release'

    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Wait for container to be running
        run: |
          echo "Waiting for container to reach Running state..."
          for i in {1..30}; do
            STATE=$(az container show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.AZURE_CONTAINER_NAME }} \
              --query instanceView.state -o tsv)

            echo "Attempt $i/30 - State: $STATE"

            if [ "$STATE" == "Running" ]; then
              echo "âœ“ Container is running"
              exit 0
            fi

            sleep 10
          done

          echo "âš  Container did not reach Running state within timeout"
          exit 1

      - name: Check container health
        run: |
          # Get container IP
          CONTAINER_IP=$(az container show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_NAME }} \
            --query ipAddress.ip -o tsv)

          echo "Testing WebSocket endpoint at $CONTAINER_IP:8080"

          # Test WebSocket upgrade (should get 400 Bad Request for HTTP GET)
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$CONTAINER_IP:8080 || echo "000")

          if [ "$HTTP_CODE" == "400" ]; then
            echo "âœ“ WebSocket endpoint is responding (HTTP 400 as expected)"
          else
            echo "âš  Unexpected HTTP response: $HTTP_CODE"
            exit 1
          fi

      - name: Show final logs
        if: always()
        run: |
          echo "Final container logs:"
          az container logs \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_CONTAINER_NAME }}
